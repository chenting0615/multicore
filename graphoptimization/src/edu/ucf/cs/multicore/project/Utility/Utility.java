package edu.ucf.cs.multicore.project.Utility;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.PrintStream;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Properties;import java.util.Set;import java.util.StringTokenizer;import org.apache.log4j.Level;import org.apache.log4j.Logger;public class Utility{	public static Logger log = Logger.getLogger(Utility.class);	public static void log(Level level, String msg)	{		AppLogger.getInstance().log(level, msg);	}	public static void deleteFile(String fileName)	{		File fileToDelete = new File(fileName);		fileToDelete.delete();	}	public static String commandToFileConvert(String command)	{		Long sysTime = new Long(System.currentTimeMillis());		// to know whether DU running on windows or unix machine		// depending on that create cmd file (bat or sh)		String fileName = Constants.EMPTY_STRING;		String echoString = Constants.EMPTY_STRING;		if (System.getProperty(Constants.ALL_OS_GETPROPERTY_PARAM).toLowerCase().indexOf(Constants.OS_WIN) >= Constants.SUCCESS)		{			fileName = Constants.TEMP_CMD_FILEPATH + File.separator + sysTime.toString()					+ Constants.WIN_SRICPT_EXTENSION;			echoString = Constants.ECHO_OFF;		}		else		{			fileName = Constants.TEMP_CMD_FILEPATH + File.separator + sysTime.toString()					+ Constants.UNIX_SRICPT_EXTENSION;		}		File folderChk = new File(Constants.TEMP_CMD_FILEPATH);		if (!folderChk.exists()) // if tmp folder not created then create it		{			if (!folderChk.mkdir())			{				if (ResourceString.getLocale() != null)					Utility.log(Level.ERROR, ResourceString.getString("cant_create_folder") + folderChk.toString());				else					System.out.println("cant create folder" + folderChk.toString());				return Constants.EMPTY_STRING;			}		}		// /write into file		BufferedWriter flwrt;		try {			flwrt = new BufferedWriter(new FileWriter(fileName));			flwrt.write(echoString);			flwrt.newLine();			flwrt.write(command);			flwrt.write(" > " + fileName + ".out 2>&1");			flwrt.newLine();			flwrt.write("exit 0");			flwrt.close();		}		catch (IOException IOEx)		{			if (ResourceString.getLocale() != null)				Utility.log(Level.ERROR, ResourceString.getString("ioex_executing_cmd") + fileName);			else				System.out.println("ioex while creating file " + fileName);			Utility.log(Level.ERROR, IOEx.getLocalizedMessage());			return Constants.EMPTY_STRING;		}		fileName = command;		return fileName;	}	public static int checkYesNo(String value)	{		if (null == value || value.equals(Constants.EMPTY_STRING))		{			// for nor providing any value			Utility.log(Level.ERROR, ResourceString.getString("attribute_missing"));			return Constants.ONE;		}		else		{			if (value.length() > Constants.ONE)			{				Utility.log(Level.ERROR, ResourceString.getString("length_error"));				return Constants.THREE;			}			// if dependent is 'y'			if (Constants.SUCCESS == value.compareToIgnoreCase(Constants.STR_YES))			{				// for 'y'				return Constants.ZERO;			}			else if (Constants.SUCCESS == value.compareToIgnoreCase(Constants.STR_NO))			{				// for 'n'				return Constants.MINUS_ONE;			}			else			{				Utility.log(Level.ERROR, ResourceString.getString("value_error"));				return Constants.TWO;			}		}	}	/**	 * 	 * This method reads the property file (key = value format file) and	 * 	 * returns value for the key provided to method.	 * 	 * 	 */	@SuppressWarnings("unused")	public static String getPropertyValue(String propertyFileName, String key)	{		FileInputStream pathFile = null;		Properties file_Properties_Obj;		String value = null;		try		{			pathFile = new FileInputStream(propertyFileName);			if (pathFile == null)				return null;			file_Properties_Obj = new Properties();			file_Properties_Obj.load(pathFile);			pathFile.close();			value = file_Properties_Obj.getProperty(key);		}		catch (FileNotFoundException e)		{			Utility.log(Level.ERROR, ResourceString.getString("exeception_get_proprty_value") + e.getLocalizedMessage());			System.out.println(e.getMessage());		} // End of Catch		catch (IOException e)		{			Utility.log(Level.ERROR, ResourceString.getString("exeception_get_proprty_value") + e.getLocalizedMessage());			System.out.println(e.getMessage());		} // End of catch		catch (Exception e)		{			Utility.log(Level.ERROR, ResourceString.getString("exeception_get_proprty_value") + e.getLocalizedMessage());			System.out.println(e.getMessage());		}		return value;	}// getPropertyValue()	/**	 * 	 * @param conf	 *            File object	 * 	 * @return true/false = true/ false boolean.	 */	@SuppressWarnings({ "rawtypes", "resource", "unchecked" })	public static int readConfDataFile(String confFileName, HashMap confData)	{		File confFile = new File(confFileName);		// Check the file permisions and the if the file is exists		if (confFile.exists() == false)		{			Utility.log(Level.ERROR, confFileName + Constants.STR_SPACE + ResourceString.getString("filenotfound"));			return Constants.FAILURE;		}		// Check the file permisions		if (confFile.canRead() == false)		{			Utility.log(Level.ERROR,					confFileName + Constants.STR_SPACE + ResourceString.getString("fillnotreadpermision"));			return Constants.FAILURE;		}		// keys are set with uppercase of file name and key with colon se		String fileName = confFile.getAbsolutePath();		int sepPos = fileName.lastIndexOf(File.separator);		if (sepPos >= Constants.SUCCESS)			fileName = fileName.substring(sepPos + 1);		fileName = fileName.toUpperCase().trim();		try		{			FileReader fr = new FileReader(confFile);			BufferedReader DataInput = new BufferedReader(fr);			String line = "";			StringTokenizer st = null;			// Reading line after line of the conf file			while ((line = DataInput.readLine()) != null)			{				String key;				String value;				// Egnore the line if it is commented and empty				if ((line.trim().length() > 0) && (!line.trim().startsWith(Constants.CONF_COMMENT)))				{					// The line using stringToken as the file format is					// key=value					st = new StringTokenizer(line, Constants.STR_EQUAL);					key = st.nextToken().trim().toUpperCase();					key = fileName + Constants.STR_COLON + key;					if (st.hasMoreTokens())					{						value = st.nextToken().trim();						confData.put(key, value);					}					else					{						Utility.log(Level.DEBUG, ResourceString.getString("novalueinfile") + Constants.STR_SPACE								+ confFileName + Constants.STR_SPACE + "Key " + key);					}					st = null;				}			}// end of while			return Constants.SUCCESS;		}		catch (IOException e)		{			Utility.log(Level.ERROR, e.getMessage());			return Constants.FAILURE;		}	}// end of readConfFile	public static String runCommand(String commandToRun, String OS)	{		String output = "";		Utility.log(Level.DEBUG, ResourceString.getString("Running_command") + commandToRun);		// gets runtime class instance		Runtime runtime = Runtime.getRuntime();		runtime.traceInstructions(true);		runtime.traceMethodCalls(true);		runtime.gc();		// create process object to handle result		Process process = null;		// create a batch or script out of this command and then run it		// we handle to run wuindows and unix separately		String fileName = Utility.commandToFileConvert(commandToRun);		if (fileName.equals(Constants.EMPTY_STRING))		{			Utility.log(Level.ERROR, ResourceString.getString("Script_to_excute_cannot_be_created"));			output = ResourceString.getString("Script_to_excute_cannot_be_created");			return output;		}		String fileToRun = Constants.EMPTY_STRING;		try		{			String cmdOSName = OS.toLowerCase();			if (cmdOSName.equals(Constants.OS_WIN))			{				fileToRun = Constants.WINDOWS_SHELL + fileName;				process = runtime.exec(fileToRun);				Utility.log(Level.DEBUG, "Utility: ran cmd: " + fileToRun);			}			/*else			{				LocalUnixConnection conn = new LocalUnixConnection();				try {					conn.connect();				} catch (Exception e2) {					// TODO Auto-generated catch block					e2.printStackTrace();				}				try {					output = conn.executeCommand(commandToRun);				} catch (Exception e1) {					// TODO Auto-generated catch block					e1.printStackTrace();				}				if (output.trim().length() == 0)				{					for (int k = 0; output.trim().length() == 0 && k < 1; k++)					{						Utility.log(Level.DEBUG, ResourceString.getString("time_out_retry") + k);						try {							output = conn.executeCommand(commandToRun);						} catch (Exception e) {							// TODO Auto-generated catch block							e.printStackTrace();						}					}				}				Utility.log(Level.DEBUG, ResourceString.getString("cmd_fired") + commandToRun +				Constants.CHR_NEWLINE +				ResourceString.getString("output") + output);				conn.disConnect();				return output;			}*/			CommandOutputReader cmdError = new CommandOutputReader(process.getErrorStream());			CommandOutputReader cmdOutput = new CommandOutputReader(process.getInputStream());			cmdOutput.setName("Out: " + commandToRun);			cmdError.setName("Err: " + commandToRun);			cmdError.start();			cmdOutput.start();			while (true) {				if (cmdError.isDone() && cmdOutput.isDone()) {					break;				}				else {					try {						Thread.sleep(200);					}					catch (InterruptedException ex) {					}				}			}			Utility.log(Level.DEBUG, "Utility: threads done: " + commandToRun);			int retValue = process.waitFor();			Utility.log(Level.DEBUG, "Utility: waitFor done: " + commandToRun);			/*			 * 			 * None of the thread needs to be stop'ed explicitly			 * 			 * CommandOutputReader threads end when they are done			 * 			 * with reading the command output, and CheckProcess			 * 			 * thread ends when the time out occurs			 */			Utility.log(Level.DEBUG, "Utility: output read for : \n" + commandToRun + "\n" + output);			if (Constants.SUCCESS != retValue)			{				retValue = process.exitValue();				Utility.log(Level.ERROR,						Constants.STR_ERROR + retValue + ResourceString.getString("while_executing_command")								+ commandToRun.toString());			}			else			{			}			output = cmdOutput.getOutputData() + " " + cmdError.getOutputData();			Utility.deleteFile(fileName);			return output;		}		catch (InterruptedException interruptedEx)		{			System.out.println("InterruptedException while executing command " + commandToRun.toString());			Utility.log(Level.ERROR,					ResourceString.getString("Intr_Exception_while_exec_command") + commandToRun.toString());			System.out.println(interruptedEx.getMessage());			Utility.log(Level.ERROR, interruptedEx.getMessage());			output = Constants.STR_ERROR + ResourceString.getString("Intr_Exception_while_exec_command")					+ Constants.CHR_NEWLINE;			output += interruptedEx.getMessage();			return output;		}		catch (IOException IOEx)		{			System.out.println("IOEx while executing command " + commandToRun.toString());			Utility.log(Level.ERROR, ResourceString.getString("IOEx_while_exec_command") + commandToRun.toString());			System.out.println(IOEx.getMessage());			Utility.log(Level.ERROR, IOEx.getMessage());			output = ResourceString.getString("IOEx_while_exec_command") + "\n";			output += IOEx.getMessage();			return output;		}	}	@SuppressWarnings("resource")	public static String fileReader(String fileName)	{		String output = "";		BufferedReader flrdr;		try {			flrdr = new BufferedReader(new FileReader(fileName));			String line;			while ((line = flrdr.readLine()) != null)			{				output += line + "\r\n";			}		}		catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}		return output;	}	/**	 * 	 * This method write contents to file	 * 	 * @param filename	 *            and contetns	 * 	 * @return success or failure 0/1 resp	 */	public static int fileWriter(String fileName, String contents)	{		FileOutputStream out; // declare a file output object		PrintStream p; // declare a print stream object		try		{			// Create a new file output stream			// connected to "myfile.txt"			out = new FileOutputStream(fileName);			// Connect print stream to the output stream			p = new PrintStream(out);			p.println(contents);			p.close();			return 0;		}		catch (Exception e)		{			System.err.println("Error writing to file");			return 1;		}	}	/**	 * 	 * This method returns keys used in the map given as input	 * 	 * @param hashMap	 * 	 * @return SEMICOLON seprated String of keys	 */	@SuppressWarnings("rawtypes")	public static String getKeys(HashMap hashMap)	{		// key String		String keys = "";		try		{			// Getting Data from HashMap.			if (hashMap != null && hashMap.size() > 0)			{				// Get a set of the entries				Set set = hashMap.entrySet();				// Get an iterator				Iterator KeyCounter = set.iterator();				// Get Keys elements				while (KeyCounter.hasNext())				{					Map.Entry me = (Map.Entry) KeyCounter.next();					keys += me.getKey();					;					keys += Constants.STR_SEMICOLON;				}// While()				keys = keys.substring(0, keys.length() - 1);			}// if()		}// try		catch (Exception e)		{			Utility.log(Level.ERROR, ResourceString.getString("error_in_getkeys_from_map") + e.getLocalizedMessage());		}		return keys;	}// Method getKeys();}